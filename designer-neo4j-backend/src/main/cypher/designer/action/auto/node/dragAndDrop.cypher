/*
@name designer.action.auto.node.dragAndDrop

@mode read
@input view, NODE
@input node, NODE

@output name, STRING
@output group, STRING
@output icon, STRING
@output params, LIST OF MAP
@output implicitParams, LIST OF STRING
@output hidden, BOOLEAN
*/

WITH $view AS view,
     custom.util.graphObjectType($node) AS nodeType

MATCH (view)-[:HAS_FUNCTIONALITY]->(func:Functionality)-[:AUTOGENERATED_FROM]->(metagraph:Metagraph)

CALL {
    WITH metagraph, nodeType
    MATCH (metagraph)-[:DEFINES]->(startNodeDef:NodeDef {name: nodeType})<-[:REL_SOURCE]-(relDef:RelDef)
    RETURN  startNodeDef, relDef

    UNION

    WITH metagraph, nodeType
    MATCH (metagraph)-[:DEFINES]->(startNodeDef:NodeDef {name: nodeType})-[:SUBCLASS_OF*1..]->(abstractNodeDef:AbstractNodeDef)<-[:REL_SOURCE]-(relDef:RelDef)
    RETURN  startNodeDef, relDef
}

WITH startNodeDef, collect(distinct relDef.name) as possibleRels

RETURN 'addRelationship' AS name,
       null AS group,
       null AS icon,
       [{name: 'endNodeUuid', widget: null}, {name: 'type', widget: 'dropDown', initValues: possibleRels}] AS params,
       [startNodeDef.uuid] AS implicitParams,
       false AS hidden;


/*
@name designer.action.auto.node.dragAndDrop_do

@mode write

@input contextUuid, STRING
@input viewUuid, STRING
@input params, MAP
@input implicitParams, LIST OF STRING

@output strategy, STRING
@output message, STRING
@output statusCode, INTEGER
@output result, MAP
*/

WITH $contextUuid AS contextUuid,
     head($implicitParams) AS startNodeDefUuid,
     $params['endNodeUuid'] AS endNodeUuid,
     $params['type'] AS relationType

MATCH (contextNode {uuid: contextUuid})
MATCH (endNode {uuid: endNodeUuid})

CALL {
    WITH startNodeDefUuid, relationType, endNode
    OPTIONAL MATCH(startNodeDef:NodeDef {uuid: startNodeDefUuid})<-[:REL_SOURCE]-(relDef:RelDef {name: relationType})
                    -[:REL_TARGET]->(:NodeDef {name: custom.util.graphObjectType(endNode)})
    RETURN relDef

    UNION

    WITH startNodeDefUuid, relationType, endNode
    OPTIONAL MATCH(startNodeDef:NodeDef {uuid: startNodeDefUuid})<-[:REL_SOURCE]-(relDef:RelDef {name: relationType})
                    -[:REL_TARGET]->(abstractNodeDef:AbstractNodeDef)<-[:SUBCLASS_OF*1..]-(:NodeDef {name: custom.util.graphObjectType(endNode)})
    RETURN relDef

    UNION

    WITH startNodeDefUuid, relationType, endNode
    OPTIONAL MATCH(startNodeDef:NodeDef {uuid: startNodeDefUuid})-[:SUBCLASS_OF*1..]->(abstractNodeDef:AbstractNodeDef)<-[:REL_SOURCE]-(relDef:RelDef {name: relationType})
                    -[:REL_TARGET]->(:NodeDef {name: custom.util.graphObjectType(endNode)})
    RETURN relDef

    UNION

    WITH startNodeDefUuid, relationType, endNode
    OPTIONAL MATCH(startNodeDef:NodeDef {uuid: startNodeDefUuid})-[:SUBCLASS_OF*1..]->(abstractNodeDef:AbstractNodeDef)<-[:REL_SOURCE]-(relDef:RelDef {name: relationType})
    OPTIONAL MATCH (relDef)-[:REL_TARGET]->(abstractNodeDef:AbstractNodeDef)<-[:SUBCLASS_OF*1..]-(:NodeDef {name: custom.util.graphObjectType(endNode)})
    RETURN relDef
}


CALL apoc.do.when(relDef IS NULL,
                  '
                  RETURN null AS rel
                  ',
                  '
                  CALL apoc.create.relationship($startNode, $type, {uuid: randomUUID()}, $endNode) YIELD rel
                  RETURN rel',
                  {startNode: contextNode,
                   type: relationType,
                   endNode: endNode}) YIELD value AS createdRel

RETURN CASE
         WHEN createdRel.rel IS NULL THEN 1
         ELSE 0
         END AS statusCode,
       CASE WHEN createdRel.rel IS NULL THEN 'Cannot create relationship of this type ' + relationType
         ELSE ''
         END AS message,
       'APPEND' AS strategy,
       createdRel AS result;